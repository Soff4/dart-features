// Values and References Types
/*
  На виході отримаємо 5 - це тому, що в Dart примітивні типи даних, такі як int, є value types, а отже, вони передаються у функцію за значенням (pass by value).
  У рядку modifyValueType(x); ми передаємо копію значення x (тобто 5) у функцію modifyValueType. Всередині функції ми модифікуємо цю копію, присвоюючи їй значення 10:
  Тобто у цій функції значення х буде дорівнювати 10.
*/
int valueTypes() {
  int x = 5;
  modifyValueType(x);
  return x;
}

/*
  З іншого боку, для reference types, таких як List<int>, ситуація інша. 
  У рядку modifyReferenceType(list); ми передаємо посилання на сам об'єкт list у функцію modifyReferenceType. 
  Всередині функції ми модифікуємо елемент під індексом 0 цього об'єкта:
 */
List<int> referenceTypes() {
  List<int> list = [1, 2, 3];
  modifyReferenceType(list);
  return list;
}

void modifyValueType(int value) {
  value = 10;
}

void modifyReferenceType(List<int> list) {
  list[0] = 4;
  list[1] = list[0] + 2;
}

/*
  Що стосується value types та references types у мові програмування Dart є значні відмінності. 
  При передачі до функції аргументом значення змінних, які мають примітивний тип даних - ми передаємо лише копію.
  В той час, як з references types ми передаємо посилання на об'єкт, який ми можемо змінювати в інших фугнкціях.
*/

// Stack and Heap
/*
  Примітивні типи даних мають фіксований розмір і відомі під час компіляції. 
  Це означає, що компілятор може визначити скільки пам'яті потрібно для зберігання цього значення. 
  Оскільки стек є областю пам'яті з фіксованим розміром та швидким доступом, він ідеально підходить для зберігання таких невеликих і фіксованих за розміром значень.
*/
int getValueTypeInstance() {
  int y = 10;
  return y;
}

/*
  На відміну від примітивних типів, об'єкти (класи, списки, мапи тощо) можуть мати різні розміри та складну внутрішню структуру. 
  Розмір цих об'єктів часто невідомий під час компіляції, оскільки їх фактичні розміри можуть залежати від даних, що зберігаються в них під час виконання.
  Для зберігання таких динамічних об'єктів використовується хіп - область пам'яті, яка може розширюватися за потреби. 
  Коли ви створюєте екземпляр об'єкта, пам'ять на хіпі динамічно виділяється для зберігання цього об'єкта. 
  Замість копіювання самого об'єкта змінній присвоюється посилання (reference) на цей об'єкт у пам'яті хіпа.
*/
List<int> getReferenceTypeInstance() {
  List<int> anotherList = [5, 6, 7];
  return anotherList;
}
/*
  Тобто вся різния в способі зберігання цих двох типів.
*/

// Garbage collection
List<int>? createAndCollectList() {
  List<int>? toBeCollected = [8, 9, 10];
  print('List before collection: $toBeCollected');

  toBeCollected = null;
  print('List set to null, will be collected by garbage collector. Null: ${toBeCollected}. \n');

  return null;
}

/*
  У Dart використовується генераційний garbage collector з компактифікацією. 
  Це означає, що об'єкти розподіляються в різних поколіннях (generation) на основі їх віку, і garbage collector працює з різними поколіннями по-різному.
  Garbage collector періодично запускається для очищення пам'яті.
  Завдяки генераційному підходу, garbage collector може ефективно працювати з об'єктами різного віку. 
  Молоді об'єкти збираються частіше, оскільки вони, як правило, короткоживучі. 
  Старі об'єкти збираються рідше, але під час їх збирання витрачається більше ресурсів.

  Загалом, garbage collector в Dart є потужним інструментом для автоматичного керування пам'яттю, 
  що дозволяє розробникам зосередитися на логіці додатку, не турбуючись про деталі виділення та звільнення пам'яті.
*/